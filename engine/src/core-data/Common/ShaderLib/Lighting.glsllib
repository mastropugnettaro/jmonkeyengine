#if defined NUMLIGHTS && NUMLIGHTS >= 2
    uniform vec4 g_LightPosition[NUMLIGHTS];
    uniform vec4 g_LightColor[NUMLIGHTS];
    uniform vec4 g_LightDirection[NUMLIGHTS];
#else
    uniform vec4 g_LightPosition;
    uniform vec4 g_LightColor;
    uniform vec4 g_LightDirection;
#endif

uniform vec4 g_AmbientLightColor;

float Lighting_DotTangent(in vec3 v1, in vec3 v2){
    float d = dot(v1, v2);
    #ifdef V_TANGENT
        d = 1.0 - d * d;
        return step(0.0, d) * sqrt(d);
    #else
        return d;
    #endif
}

float Lighting_Diffuse(in vec3 norm, in vec3 viewdir, in vec3 lightdir){
    #ifdef MINNAERT
       float NdotL = max(0.0, dot(norm, lightdir));
       float NdotV = max(0.0, dot(norm, viewdir));
       return NdotL * pow(max(NdotL * NdotV, 0.1), -1.0) * 0.5;
    #else
       return max(0.0, dot(norm, lightdir));
    #endif
}

float Lighting_Specular(in vec3 norm, in vec3 viewdir, in vec3 lightdir, in float shiny){
      // NOTE: check for shiny <= 1 removed since shininess is now 
      // 1.0 by default (uses matdefs default vals)
      #if defined(LOW_QUALITY)
        // Blinn-Phong
        // Note: preferably, H should be computed in the vertex shader
        vec3 H = (viewdir + lightdir) * vec3(0.5);
        return pow(max(Lighting_DotTangent(H, norm), 0.0), shiny);
      #elif defined(WARDISO)
        // Isotropic Ward
        vec3 halfVec = normalize(viewdir + lightdir);
        float NdotH  = max(0.001, Lighting_DotTangent(norm, halfVec));
        float NdotV  = max(0.001, Lighting_DotTangent(norm, viewdir));
        float NdotL  = max(0.001, Lighting_DotTangent(norm, lightdir));
        float a      = tan(acos(NdotH));
        float p      = max(shiny/128.0, 0.001);
        return NdotL * (1.0 / (4.0*3.14159265*p*p)) * (exp(-(a*a)/(p*p)) / (sqrt(NdotV * NdotL)));
    #else
       // Standard Phong
       vec3 R = reflect(-lightdir, norm);
       return pow(max(Lighting_DotTangent(R, viewdir), 0.0), shiny);
    #endif
}

float Lighting_SpotFalloff(in vec3 wLightSpotDir, in vec3 wvLightVec) {
     float spotFallOff = 1.0;
 
     #if !defined(LIGHTTYPE) || LIGHTTYPE == 3
        #if !defined(LIGHTTYPE) && __VERSION__ >= 110
            // Use control flow if we are using a dynamic
            // light mode with a GPU that supports control flow
            if (g_LightDirection.w != 0.0) {
        #endif
           
           float curAngleCos = dot(-wvLightVec, wLightSpotDir.xyz);    
           float innerAngleCos = floor(g_LightDirection.w) * 0.001;
           float outerAngleCos = fract(g_LightDirection.w);
           float innerMinusOuter = innerAngleCos - outerAngleCos;
           spotFallOff = clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0, 1.0);

        #if !defined(LIGHTTYPE) && __VERSION__ >= 110
            }
        #endif
     #endif

     return spotFallOff;
}

vec2 Lighting_Compute(in vec3 wvNorm, in vec3 wvViewDir, in vec4 wvLightDir, in vec3 wvLightSpotDir, float shininess) {
     float diffuseFactor  = Lighting_Diffuse (wvNorm, wvViewDir, wvLightDir.xyz);
     float specularFactor = Lighting_Specular(wvNorm, wvViewDir, wvLightDir.xyz, shininess);
     float spotFallOff    = Lighting_SpotFalloff(wvLightSpotDir, wvLightDir.xyz);

     if (shininess <= 1.0) {
        specularFactor = 0.0;
     }

     specularFactor *= diffuseFactor;

     return vec2(diffuseFactor, specularFactor) * 
            vec2(wvLightDir.w) *
            spotFallOff;
}

vec4 Lighting_Direction(in vec3 worldPos, in vec4 color, in vec4 position) {
    #ifdef LIGHTTYPE
        #if LIGHTTYPE == 1
            vec3 dir = position.xyz;
            dir.xyz = dir.xyz * vec3(-1.0, -1.0, -1.0);
            // Directional lights are simple.
            // No attenuation or normalization needed
            // return vec4(position.xyz * vec3(-1.0), 1.0);
            return vec4(dir, 1.0);
        #else
            // Point / Spot lights
            vec3 tempVec = position.xyz - worldPos;
            #ifdef ATTENUATION
               float dist = length(tempVec);
               return vec4( tempVec / vec3(dist),
                            clamp(1.0 - position.w * dist, 0.0, 1.0) );
            #else
               return vec4(normalize(tempVec), 1.0);
            #endif
        #endif
    #else
        // Determine based on uniform
        float posLight = step(0.5, color.w);
        vec3 tempVec = position.xyz * sign(posLight - 0.5) - (worldPos * posLight);
        float dist = length(tempVec);
        return vec4( tempVec / vec3(dist),
                     clamp(1.0 - position.w * dist, 0.0, 1.0) );
    #endif
}
